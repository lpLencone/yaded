

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  
  <meta charset="utf-8" />
  
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>FAQ &mdash; RenderDoc documentation</title>
  

  
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />

  
  

  
  
    <link rel="canonical" href="https://renderdoc.org/docs/getting_started/faq.html"/>
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Gotchas &amp; Known Issues" href="gotchas_known_issues.html" />
    <link rel="prev" title="Quick Start" href="quick_start.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> RenderDoc
          

          
          </a>

          
            
            
              <div class="version">
                1.28
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../credits_acknowledgements.html">Credits &amp; Acknowledgements</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Getting started</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="quick_start.html">Quick Start</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">FAQ</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#what-are-the-details-of-renderdoc-s-anonymous-analytics">What are the details of RenderDoc’s Anonymous Analytics?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#how-do-i-do-some-particular-task">How do I do some particular task?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#why-did-you-make-renderdoc">Why did you make RenderDoc?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#where-did-the-name-come-from">Where did the name come from?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#who-can-i-contact-about-bugs-feature-requests-other-queries">Who can I contact about bugs, feature requests, other queries?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#how-can-i-associate-renderdoc-s-file-extensions-with-the-program">How can I associate RenderDoc’s file extensions with the program?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#what-apis-does-renderdoc-support">What APIs does RenderDoc support?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#how-can-i-backup-or-restore-my-settings">How can I backup or restore my settings?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#which-network-ports-does-renderdoc-use">Which network ports does RenderDoc use?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#where-can-i-get-the-source-to-renderdoc">Where can I get the source to RenderDoc?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#what-are-the-requirements-for-renderdoc">What are the requirements for RenderDoc?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#why-does-my-capture-say-failed-to-capture-frame-uncapped-command-list">Why does my capture say “Failed to capture frame: Uncapped command list”?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#why-does-my-capture-say-failed-to-capture-frame-uncapped-map-unmap">Why does my capture say “Failed to capture frame: Uncapped Map()/Unmap()”?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#gamma-display-of-linear-data-or-why-doesn-t-my-texture-look-right">Gamma display of linear data, or “Why doesn’t my texture look right?”</a></li>
<li class="toctree-l3"><a class="reference internal" href="#renderdoc-makes-my-bug-go-away-or-causes-new-artifacts-that-weren-t-there">RenderDoc makes my bug go away! Or causes new artifacts that weren’t there</a></li>
<li class="toctree-l3"><a class="reference internal" href="#i-can-t-launch-my-program-for-capture-directly-can-i-capture-it-anyway">I can’t launch my program for capture directly. Can I capture it anyway?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#i-d-like-to-use-renderdoc-s-texture-viewer-for-dds-files-or-other-images-can-i">I’d like to use RenderDoc’s texture viewer for dds files, or other images. Can I?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#i-think-i-might-be-overwriting-map-boundaries-or-relying-on-undefined-buffer-contents-can-i-check-this">I think I might be overwriting Map() boundaries or relying on undefined buffer contents, can I check this?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#renderdoc-is-complaining-about-my-opengl-app-in-the-overlay-what-gives">RenderDoc is complaining about my OpenGL app in the overlay - what gives?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#can-i-tell-via-the-graphics-apis-if-renderdoc-is-present-at-runtime">Can I tell via the graphics APIs if RenderDoc is present at runtime?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#my-shaders-have-cbuffer0-and-unnamed-variables-how-do-i-get-proper-debug-info">My shaders have ‘cbuffer0’ and unnamed variables, how do I get proper debug info?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#i-want-to-debug-a-child-process-that-my-program-launches-how-can-i-inject-renderdoc">I want to debug a child process that my program launches, how can I inject RenderDoc?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#i-m-debugging-a-program-using-an-opengl-es-emulator-how-can-i-capture-the-underlying-api">I’m debugging a program using an OpenGL ES emulator, how can I capture the underlying API?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#when-i-launch-my-application-through-renderdoc-why-can-t-i-access-the-api-validation">When I launch my application through RenderDoc, why can’t I access the API validation?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#if-i-have-multiple-gpus-available-which-one-is-used-by-renderdoc-can-i-change-that">If I have multiple GPUs available, which one is used by RenderDoc? Can I change that?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#what-is-a-drawcall">What is an Action?</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="gotchas_known_issues.html">Gotchas &amp; Known Issues</a></li>
<li class="toctree-l2"><a class="reference internal" href="features.html">Features</a></li>
<li class="toctree-l2"><a class="reference internal" href="tips_tricks.html">Tips &amp; Tricks</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../behind_scenes/index.html">Behind the scenes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../in_application_api.html">In-application API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python_api/index.html">Python API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../how/index.html">How do I …?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../window/index.html">Window reference</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">RenderDoc</a>
        
      </nav>
      


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          
          
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Getting started</a> &raquo;</li>
        
      <li>FAQ</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            
              <a href="https://github.com/baldurk/renderdoc/blob/v1.28/docs/getting_started/faq.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="faq">
<h1>FAQ<a class="headerlink" href="#faq" title="Permalink to this heading">¶</a></h1>
<p>Here is a list of commonly asked questions about RenderDoc. Feel free to <a class="reference external" href="mailto:baldurk&#37;&#52;&#48;baldurk&#46;org?subject=RenderDoc%20question">contact me</a> if you have another question that isn’t covered here or in this document.</p>
<section id="what-are-the-details-of-renderdoc-s-anonymous-analytics">
<h2>What are the details of RenderDoc’s Anonymous Analytics?<a class="headerlink" href="#what-are-the-details-of-renderdoc-s-anonymous-analytics" title="Permalink to this heading">¶</a></h2>
<p>RenderDoc has some very light anonymous analytics to allow analysis of which features and platforms are used more, to prioritise and guide future development.</p>
<p>The complete details of the analytics can be found in the page about <a class="reference internal" href="../behind_scenes/analytics.html"><span class="doc">Analytics</span></a>, but the brief outline is that RenderDoc records data <strong>only in the replay program</strong> and does not record any data that is specific to any captured programs. The data recorded is primarily boolean flags indicating whether or not a given feature, API, or platform is used or not. You can see the precise list of data gathered on your current RenderDoc build in the settings menu under the <span class="guilabel">Anonymous Analytics</span> section.</p>
<p>The analytics data is summarised and transmitted securely and anonymously to RenderDoc’s server. The aggregated statistics are available for anyone to see at <a class="reference external" href="https://renderdoc.org/analytics">the analytics homepage</a>.</p>
<p>Enabling the analytics is greatly appreciated, if you have any concerns about the data gathered you can choose to manually verify each report before it’s submitted.</p>
</section>
<section id="how-do-i-do-some-particular-task">
<h2>How do I do some particular task?<a class="headerlink" href="#how-do-i-do-some-particular-task" title="Permalink to this heading">¶</a></h2>
<p>Many specific tasks or functions are detailed in the <a class="reference internal" href="../how/index.html"><span class="doc">“How Do I… ?”</span></a> sections. These sections each take a feature or element of a workflow and explain how it fits into the program as a whole as well as any details of how it works.</p>
<p>If the task you have in mind isn’t listed there you might find something similar, or you might find a related feature which can be used to do what you want. If you have a workflow which isn’t supported at all, feel free to open an issue on github to request a new feature. Make sure to describe clearly what you are trying to do and what workflow you want to support, not just the specific feature you want. That way the problem can be better understood.</p>
</section>
<section id="why-did-you-make-renderdoc">
<h2>Why did you make RenderDoc?<a class="headerlink" href="#why-did-you-make-renderdoc" title="Permalink to this heading">¶</a></h2>
<p>Although several tools do already exist for graphics debugging, none of them quite suited the functionality I desired and I would often find myself wishing for a feature of one in another and vice versa.</p>
<p>In addition to this, although the functionality overlaps to some degree many of these tools were primarily designed around the profiling of applications rather than debugging. While being able to inspect the state and contents of resources does often suffice for debugging, it’s not necessarily the ideal workflow and often it can become cumbersome.</p>
<p>In principle I didn’t see any reason why I couldn’t write a home-brew graphics debugger with some fairly simple operating principles. While there were a whole lot of caveats and little stumbling blocks along the way, the original design has pretty much stayed consistent since the project was started back in July 2012. If you’re interested you might want to read about <a class="reference internal" href="../behind_scenes/how_works.html"><span class="doc">How RenderDoc works</span></a>.</p>
</section>
<section id="where-did-the-name-come-from">
<h2>Where did the name come from?<a class="headerlink" href="#where-did-the-name-come-from" title="Permalink to this heading">¶</a></h2>
<p>All of the good names were taken :-(.</p>
</section>
<section id="who-can-i-contact-about-bugs-feature-requests-other-queries">
<h2>Who can I contact about bugs, feature requests, other queries?<a class="headerlink" href="#who-can-i-contact-about-bugs-feature-requests-other-queries" title="Permalink to this heading">¶</a></h2>
<p>At the moment there’s just me at the wheel - feel free to <a class="reference external" href="mailto:baldurk&#37;&#52;&#48;baldurk&#46;org?subject=RenderDoc%20feedback">contact me</a> if you have anything you’d like to ask or suggest. I use a <a class="reference external" href="https://github.com/baldurk/renderdoc">GitHub repository</a> for tracking bugs and feature requests so that’s the best place to file an issue.</p>
<p>I work on RenderDoc full time contracting for Valve Software, and I am happy to help with anything and work with you if you have any issues that need attention.</p>
<p>In particular I’m used to working with people who have strong NDA protection over their projects - as long as you are able to spend time to diagnose the issue by running builds and debugging by suggestion, it’s not a requirement to send me a repro case - which may be impossible.</p>
</section>
<section id="how-can-i-associate-renderdoc-s-file-extensions-with-the-program">
<h2>How can I associate RenderDoc’s file extensions with the program?<a class="headerlink" href="#how-can-i-associate-renderdoc-s-file-extensions-with-the-program" title="Permalink to this heading">¶</a></h2>
<p>On Windows if you installed RenderDoc via the msi installer, the option is available there to associate RenderDoc’s file extensions with the program.</p>
<p>On linux the binary tarball comes with files to place under <code class="docutils literal notranslate"><span class="pre">/usr/share</span></code> to associate RenderDoc with files. This obviously also requires <code class="docutils literal notranslate"><span class="pre">qrenderdoc</span></code> to be available in your <code class="docutils literal notranslate"><span class="pre">PATH</span></code>.</p>
<p>RenderDoc can be associated with <code class="docutils literal notranslate"><span class="pre">.rdc</span></code> and <code class="docutils literal notranslate"><span class="pre">.cap</span></code> files. The <code class="docutils literal notranslate"><span class="pre">.rdc</span></code> files are the frame capture containers generated from your application. <code class="docutils literal notranslate"><span class="pre">.cap</span></code> files describe the set up of a particular capture, and can be used to quickly re-launch a capture preset.</p>
<p>There is also a thumbnail handler available for <code class="docutils literal notranslate"><span class="pre">.rdc</span></code> so that while browsing through files you will get a thumbnail preview of the capture where available.</p>
</section>
<section id="what-apis-does-renderdoc-support">
<h2>What APIs does RenderDoc support?<a class="headerlink" href="#what-apis-does-renderdoc-support" title="Permalink to this heading">¶</a></h2>
<p>Currently RenderDoc supports Vulkan 1.2, D3D11 (up to D3D11.4), D3D12, OpenGL 3.2+, and OpenGL ES 2.0 - 3.2. Note that OpenGL (and similarly OpenGL ES) is a complex &amp; sprawling API, so see the details of what is supported in <a class="reference internal" href="../behind_scenes/opengl_support.html"><span class="doc">its own page</span></a>. In particular on desktop only modern GL is supported - legacy GL that is only available via the compatibility profile in OpenGL 3.2 is not supported.</p>
<p>Vulkan support has <a class="reference internal" href="../behind_scenes/vulkan_support.html"><span class="doc">a few notes</span></a>, as does <a class="reference internal" href="../behind_scenes/d3d12_support.html"><span class="doc">D3D12</span></a>.</p>
<p>Future API support is at this point not clear; Metal, WebGL, and perhaps D3D9/D3D10 all being possible. Support for new APIs will be balanced against all other work such as features for existing APIs, bugfixes. So if you care strongly about support for a new API make sure to <a class="reference external" href="https://github.com/baldurk/renderdoc/issues">file an issue on GitHub</a> or comment on an existing issue to register your interest.</p>
</section>
<section id="how-can-i-backup-or-restore-my-settings">
<h2>How can I backup or restore my settings?<a class="headerlink" href="#how-can-i-backup-or-restore-my-settings" title="Permalink to this heading">¶</a></h2>
<p>RenderDoc stores data in two folders:</p>
<p>The UI stores data in a <code class="docutils literal notranslate"><span class="pre">qrenderdoc</span></code> folder underneath your OS’s user settings folder. On windows this is <code class="docutils literal notranslate"><span class="pre">%APPDATA%</span></code> and on linux this will be somewhere in your home directory, perhaps in <code class="docutils literal notranslate"><span class="pre">~/.local/share</span></code>. Nothing in this data is machine specific aside from paths, so you can back up and restore this directory at will.</p>
<p>Deleting this folder will also reset the RenderDoc UI to the defaults - if you uninstall RenderDoc this folder will not be deleted.</p>
<p>The core code may save cached data in a <code class="docutils literal notranslate"><span class="pre">renderdoc</span></code> folder - either <code class="docutils literal notranslate"><span class="pre">%APPDATA%/renderdoc</span></code> or <code class="docutils literal notranslate"><span class="pre">~/.renderdoc/</span></code> but this doesn’t contain settings, so is not important to back up.</p>
<p>RenderDoc doesn’t install any registry keys on windows aside from those required to set up file associations.</p>
</section>
<section id="which-network-ports-does-renderdoc-use">
<h2>Which network ports does RenderDoc use?<a class="headerlink" href="#which-network-ports-does-renderdoc-use" title="Permalink to this heading">¶</a></h2>
<p>RenderDoc uses TCP and UDP ports <code class="docutils literal notranslate"><span class="pre">38920-38927</span></code> consecutively for remote access and control (i.e. capturing remotely) for each new program that is opened on a machine. Note that even if you initiate a capture locally these ports are still opened for listening. These are the ports that are probed on a remote host to see if a connection exists.</p>
<p>RenderDoc also uses TCP and UDP ports <code class="docutils literal notranslate"><span class="pre">39920</span></code> for remote replay connections, for when a remote host is used to replay and analyse the capture.</p>
</section>
<section id="where-can-i-get-the-source-to-renderdoc">
<h2>Where can I get the source to RenderDoc?<a class="headerlink" href="#where-can-i-get-the-source-to-renderdoc" title="Permalink to this heading">¶</a></h2>
<p>RenderDoc is licensed under the MIT license and the source is available on <a class="reference external" href="https://github.com/baldurk/renderdoc">GitHub</a>.</p>
</section>
<section id="what-are-the-requirements-for-renderdoc">
<h2>What are the requirements for RenderDoc?<a class="headerlink" href="#what-are-the-requirements-for-renderdoc" title="Permalink to this heading">¶</a></h2>
<p>Currently RenderDoc expects Feature Level 11.0 hardware and above for D3D11 and D3D12. Lower levels will capture successfully, but on replay RenderDoc will fall back to WARP software emulation which will run quite slowly.</p>
<p>For OpenGL RenderDoc will only capture core profile applications, in general, and expects at minimum to be able to create a core 3.2 context which includes a few key extensions. For more details see <a class="reference internal" href="../behind_scenes/opengl_support.html"><span class="doc">OpenGL &amp; OpenGL ES Support</span></a>.</p>
<p>With Vulkan, RenderDoc should fully support any Vulkan application. However replaying a Vulkan capture may not work if the hardware used to capture it is different - portability of captures between hardware is not guaranteed.</p>
</section>
<section id="why-does-my-capture-say-failed-to-capture-frame-uncapped-command-list">
<h2>Why does my capture say “Failed to capture frame: Uncapped command list”?<a class="headerlink" href="#why-does-my-capture-say-failed-to-capture-frame-uncapped-command-list" title="Permalink to this heading">¶</a></h2>
<p>On D3D11, RenderDoc only begins capturing deferred command lists at the point that you trigger a capture. If you replay command lists that were recorded before the captured frame, RenderDoc will fail to capture the frame and try again next frame (and eventually give up after a few retries).</p>
<p>To change this behaviour, enable the <code class="docutils literal notranslate"><span class="pre">Capture</span> <span class="pre">all</span> <span class="pre">cmd</span> <span class="pre">lists</span></code> option - see <a class="reference internal" href="../window/capture_attach.html"><span class="doc">Capture Dialog</span></a> for more details. This will capture all command lists recorded from the start of the program, ready for when you decide to capture a frame. This currently has a fair amount of overhead.</p>
</section>
<section id="why-does-my-capture-say-failed-to-capture-frame-uncapped-map-unmap">
<h2>Why does my capture say “Failed to capture frame: Uncapped Map()/Unmap()”?<a class="headerlink" href="#why-does-my-capture-say-failed-to-capture-frame-uncapped-map-unmap" title="Permalink to this heading">¶</a></h2>
<p>If you start a <code class="docutils literal notranslate"><span class="pre">Map()</span></code> before a <code class="docutils literal notranslate"><span class="pre">Present()</span></code> call then call <code class="docutils literal notranslate"><span class="pre">Unmap()</span></code> after the <code class="docutils literal notranslate"><span class="pre">Present()</span></code> during the frame RenderDoc wants to capture, RenderDoc won’t have intercepted this call and so will fail to capture this frame and try again next time. This usually only invalidates the first frame you try to capture, but if you <code class="docutils literal notranslate"><span class="pre">Map()</span></code> many resources, and <code class="docutils literal notranslate"><span class="pre">Unmap()</span></code> them one by one in subsequent frames, you could hit this failed capture scenario many times in a row.</p>
<p>Currently the only solution to this is to change the pattern of <code class="docutils literal notranslate"><span class="pre">Map()/Unmap()</span></code> such that they are contained within a frame.</p>
</section>
<section id="gamma-display-of-linear-data-or-why-doesn-t-my-texture-look-right">
<span id="gamma-linear-display"></span><h2>Gamma display of linear data, or “Why doesn’t my texture look right?”<a class="headerlink" href="#gamma-display-of-linear-data-or-why-doesn-t-my-texture-look-right" title="Permalink to this heading">¶</a></h2>
<p>Gamma/sRGB correctness is a rather painful subject. If we could all just agree to store everything in 32bit float data we could probably do away with it. Until that time we have to worry about displaying textures while making sure to respect the color space it’s stored in.</p>
<p>For texture formats that explicitly specify that they contain sRGB data this isn’t a problem and everything works smoothly. Note that RenderDoc shows picked texel values in linear float format, so if you pick a pixel that is 0.5, 0.5, 0.5, the actual bytes might be stored as say 186, 186, 186.</p>
<p>For other textures it’s more difficult - for starters they may actually contain sRGB data but the correction is handled by shaders so there’s no markup. Or indeed the application may not be gamma-correct so the data is sRGB but uncorrected. If we display these textures in a technically correct way, such that the data is not over or under gamma-corrected, the result often looks ‘wrong’ or unintuitively different from expected.</p>
<p>Nothing is actually wrong here except perhaps that when visualising linear data it is often more convenient to “over-correct” such that the data is perceptually linear. A good example to use is a normal map: The classic deep blue of (127,127,255) flat normals is technically incorrect as everyone is used to visualising these textures in programs that display the data as if it were sRGB (which is the convention for normal images that do not represent vectors).</p>
<p>You can override this behaviour on any texture that isn’t listed as explicitly sRGB with the gamma (γ) button - toggle this off and the over-correction will be disabled.</p>
</section>
<section id="renderdoc-makes-my-bug-go-away-or-causes-new-artifacts-that-weren-t-there">
<h2>RenderDoc makes my bug go away! Or causes new artifacts that weren’t there<a class="headerlink" href="#renderdoc-makes-my-bug-go-away-or-causes-new-artifacts-that-weren-t-there" title="Permalink to this heading">¶</a></h2>
<p>For various tedious reasons RenderDoc’s replay isn’t (and in most cases can’t be) a perfect reproduction of what your code was executing in the application when captured, and it can change the circumstances while running.</p>
<p>During capture the main impact of having RenderDoc enabled is that timings will change, and more memory (sometimes much more) will be allocated. There are also slight differences to the interception of Map() calls as they may go through an intermediate buffer to be captured. Generally the only problem this can expose is that when capturing a frame, if something is timing dependent RenderDoc causes one or two very slow frames, and can cause the bug to disappear.</p>
<p>RenderDoc also isn’t intended to handle invalid API use - this is better caught by each API’s built-in validation features. If your program is using the API in an invalid way it may break RenderDoc in the same way that it may break a driver.</p>
</section>
<section id="i-can-t-launch-my-program-for-capture-directly-can-i-capture-it-anyway">
<h2>I can’t launch my program for capture directly. Can I capture it anyway?<a class="headerlink" href="#i-can-t-launch-my-program-for-capture-directly-can-i-capture-it-anyway" title="Permalink to this heading">¶</a></h2>
<p>There is an option for capturing programs using RenderDoc where you can’t easily set up a direct launch of the process.</p>
<p>More details can be found in the <a class="reference internal" href="../window/capture_attach.html#global-process-hook"><span class="std std-ref">capture options page</span></a> which details how to use it, however you should take care to read the warnings! The global process hooking option isn’t without its risks, so you need to be sure you know what you’re doing before using it. It should always be used as a last resort when there is no other option.</p>
</section>
<section id="i-d-like-to-use-renderdoc-s-texture-viewer-for-dds-files-or-other-images-can-i">
<span id="view-image-files"></span><h2>I’d like to use RenderDoc’s texture viewer for dds files, or other images. Can I?<a class="headerlink" href="#i-d-like-to-use-renderdoc-s-texture-viewer-for-dds-files-or-other-images-can-i" title="Permalink to this heading">¶</a></h2>
<p>Yes you can!</p>
<p>Simply drag in an image file, or open it via file → open. RenderDoc will open the image if it is supported, and display it as if there were a capture open with only one texture.</p>
<p>RenderDoc supports these formats: <code class="docutils literal notranslate"><span class="pre">.dds</span></code>, <code class="docutils literal notranslate"><span class="pre">.hdr</span></code>, <code class="docutils literal notranslate"><span class="pre">.exr</span></code>, <code class="docutils literal notranslate"><span class="pre">.bmp</span></code>, <code class="docutils literal notranslate"><span class="pre">.jpg</span></code>, <code class="docutils literal notranslate"><span class="pre">.png</span></code>, <code class="docutils literal notranslate"><span class="pre">.tga</span></code>, <code class="docutils literal notranslate"><span class="pre">.gif</span></code>, <code class="docutils literal notranslate"><span class="pre">.psd</span></code>. For <code class="docutils literal notranslate"><span class="pre">.dds</span></code> files RenderDoc supports all DXGI formats, compressed formats, arrays and mips - all of which will display as expected.</p>
<p>Any modifications to the image while open in RenderDoc will be refreshed in the viewer. However if the image metadata changes (dimension, format, etc) then this will likely cause artifacts or incorrect rendering, and you’ll have to re-open the image.</p>
</section>
<section id="i-think-i-might-be-overwriting-map-boundaries-or-relying-on-undefined-buffer-contents-can-i-check-this">
<h2>I think I might be overwriting Map() boundaries or relying on undefined buffer contents, can I check this?<a class="headerlink" href="#i-think-i-might-be-overwriting-map-boundaries-or-relying-on-undefined-buffer-contents-can-i-check-this" title="Permalink to this heading">¶</a></h2>
<p>RenderDoc can be configured to insert a boundary marker at the end of the memory returned from a <code class="docutils literal notranslate"><span class="pre">Map()</span></code> call. If this marker gets overwritten during a captured frame then a message box will pop up alerting you, and clicking Yes will break into the program in the debugger so that you can investigate the callstack.</p>
<p>It will also fill buffers with undefined contents on creation with a marker value, to help catch the use of undefined contents that may be assumed to be zero.</p>
<p>To enable this behaviour, select the <code class="docutils literal notranslate"><span class="pre">Verify</span> <span class="pre">Buffer</span> <span class="pre">Access</span></code> option when <a class="reference internal" href="../window/capture_attach.html"><span class="doc">capturing</span></a>.</p>
<p>Note this is only supported on D3D11 and OpenGL currently, since Vulkan and D3D12 are lower overhead and do not have the infrastructure to intercept map writes.</p>
</section>
<section id="renderdoc-is-complaining-about-my-opengl-app-in-the-overlay-what-gives">
<h2>RenderDoc is complaining about my OpenGL app in the overlay - what gives?<a class="headerlink" href="#renderdoc-is-complaining-about-my-opengl-app-in-the-overlay-what-gives" title="Permalink to this heading">¶</a></h2>
<p>The first thing to remember is that <strong>RenderDoc only supports Core Profile 3.2 and above OpenGL</strong>. If your app is using deprecated compatibility profile features from before 3.2 it almost certainly won’t work as most functionality is not supported. A couple of things like not creating a VAO (which is required in core profile) and using luminance textures (which don’t exist in core profile) are allowed, but none of the fixed function pipeline will work, etc.</p>
<p>If your app is not using the <code class="docutils literal notranslate"><span class="pre">CreateContextAttribs</span></code> API then RenderDoc will assume your program uses legacy functionality and it will completely refuse to capture. The overlay will display text to this effect using the simplest fixed-function pipeline code, so it will run on any OpenGL app, even on a 1.4 context or similar.</p>
<p>If your app did use the <code class="docutils literal notranslate"><span class="pre">CreateContextAttribs</span></code> API, RenderDoc will allow you to capture, but compatibility profiles will have a warning displayed in the overlay - this is because you could easily use old functionality which is still available in the context.</p>
</section>
<section id="can-i-tell-via-the-graphics-apis-if-renderdoc-is-present-at-runtime">
<h2>Can I tell via the graphics APIs if RenderDoc is present at runtime?<a class="headerlink" href="#can-i-tell-via-the-graphics-apis-if-renderdoc-is-present-at-runtime" title="Permalink to this heading">¶</a></h2>
<p>Yes indeed. Some APIs offer ways to do this already - <code class="docutils literal notranslate"><span class="pre">D3DPERF_GetStatus()</span></code>, <code class="docutils literal notranslate"><span class="pre">ID3DUserDefinedAnnotation::GetStatus()</span></code> and <code class="docutils literal notranslate"><span class="pre">ID3D11DeviceContext2::IsAnnotationEnabled()</span></code>.</p>
<p>In addition to those the simplest way is to see if the RenderDoc module is loaded, using <code class="docutils literal notranslate"><span class="pre">GetModuleHandleA(&quot;renderdoc.dll&quot;)</span> <span class="pre">!=</span> <span class="pre">NULL</span></code> or <code class="docutils literal notranslate"><span class="pre">dlopen(&quot;librenderdoc.so,</span> <span class="pre">RTLD_NOW</span> <span class="pre">|</span> <span class="pre">RTLD_NOLOAD)</span> <span class="pre">!=</span> <span class="pre">NULL</span></code>. There are also API specific ways to query:</p>
<p>Querying an <code class="docutils literal notranslate"><span class="pre">ID3D11Device</span></code> or <code class="docutils literal notranslate"><span class="pre">ID3D12Device</span></code> for UUID <code class="docutils literal notranslate"><span class="pre">{A7AA6116-9C8D-4BBA-9083-B4D816B71B78}</span></code> will return an <code class="docutils literal notranslate"><span class="pre">IUnknown*</span></code> and <code class="docutils literal notranslate"><span class="pre">S_OK</span></code> when RenderDoc is present.</p>
<p><a class="reference external" href="https://renderdoc.org/debug_tool.txt">GL_EXT_debug_tool</a> is implemented on RenderDoc, which is an extension I’ve proposed for this purpose (identifying when and which tool is injected in your program). It allows you to query for the presence name and type of a debug tool that’s currently hooked. At the time of writing only RenderDoc implements this as I’ve only just proposed the extension publicly, but in future you can use the queries described in that spec.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It’s unlikely the extension will ever be ‘made official’, so these enumerants can be used:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define GL_DEBUG_TOOL_EXT                 0x6789</span>
<span class="cp">#define GL_DEBUG_TOOL_NAME_EXT            0x678A</span>
<span class="cp">#define GL_DEBUG_TOOL_PURPOSE_EXT         0x678B</span>
</pre></div>
</div>
</div>
<p>On Vulkan <cite>VK_EXT_tooling_info</cite> will return an entry for RenderDoc. This extension will always be available when running under RenderDoc.</p>
</section>
<section id="my-shaders-have-cbuffer0-and-unnamed-variables-how-do-i-get-proper-debug-info">
<h2>My shaders have ‘cbuffer0’ and unnamed variables, how do I get proper debug info?<a class="headerlink" href="#my-shaders-have-cbuffer0-and-unnamed-variables-how-do-i-get-proper-debug-info" title="Permalink to this heading">¶</a></h2>
<p>If you get textures that are just named <code class="docutils literal notranslate"><span class="pre">texture0</span></code> and <code class="docutils literal notranslate"><span class="pre">texture1</span></code> or constant/uniform buffers named <code class="docutils literal notranslate"><span class="pre">cbuffer2</span></code> then this indicates that you have stripped optional reflection/debug information out of your shaders.</p>
<p>This optional information is generated by the compiler, but is not required for API correctness so some codebases will strip the information out after processing it offline, and so it will not be available for RenderDoc to fetch. This also includes shader source for source-level shader debugging on APIs that support it.</p>
<p>The simplest solution is just to avoid stripping the data when using RenderDoc. If you can enable debugging information to be embedded when building your shaders that’s all that is necessary. All APIs will allow this data in the shader blob, but the way it is generated varies by API and shader compiler.</p>
<p>It’s not always simple to avoid that stripping, and in some cases it may not be desirable as debug information can be quite a storage and memory overhead, it may instead be better to separate out the debug information and store it in a disk cache, with only a path or identifier remaining in the stripped blob so that RenderDoc can identify the matching debug information later.</p>
<p>For more information on how to do this, see <a class="reference internal" href="../how/how_shader_debug_info.html"><span class="doc">How do I use shader debug information?</span></a>.</p>
</section>
<section id="i-want-to-debug-a-child-process-that-my-program-launches-how-can-i-inject-renderdoc">
<h2>I want to debug a child process that my program launches, how can I inject RenderDoc?<a class="headerlink" href="#i-want-to-debug-a-child-process-that-my-program-launches-how-can-i-inject-renderdoc" title="Permalink to this heading">¶</a></h2>
<p>When launching a process in RenderDoc, by default only this process is debugged and any children it launches are not affected. This better ensures compatibility for the most common case where you are able to start the process to be debugged directly.</p>
<p>In the case where your program launches sub-processes that you would like to debug, you can enable the <code class="docutils literal notranslate"><span class="pre">Capture</span> <span class="pre">Child</span> <span class="pre">Processes</span></code> capture option, which causes RenderDoc to recursively inject itself into all children (and grand-children, and so on). When you open a capture connection, the child processes will be displayed and you can open a connection to each child to locate the process you wish to debug.</p>
<p>There are <a class="reference internal" href="../window/capture_attach.html#child-process-hook"><span class="std std-ref">more details available</span></a> in the documentation for the <a class="reference internal" href="../window/capture_attach.html"><span class="doc">Capture Dialog</span></a> window.</p>
</section>
<section id="i-m-debugging-a-program-using-an-opengl-es-emulator-how-can-i-capture-the-underlying-api">
<h2>I’m debugging a program using an OpenGL ES emulator, how can I capture the underlying API?<a class="headerlink" href="#i-m-debugging-a-program-using-an-opengl-es-emulator-how-can-i-capture-the-underlying-api" title="Permalink to this heading">¶</a></h2>
<p>Wherever possible on Windows RenderDoc will capture OpenGL ES natively and ignore any underlying API calls it makes. For libraries such as ANGLE that emulate GLES on windows using calls to D3D11, this means the GLES itself gets captured and debugged.</p>
<p>If you don’t want this to happen and you’d prefer OpenGL ES to be ignored during capture you can set the <code class="docutils literal notranslate"><span class="pre">RENDERDOC_HOOK_EGL</span></code> environment variable to <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This toggle only has effect on windows. On other platforms GLES is always natively captured as it is expected to have system-level support rather than being emulated.</p>
</div>
</section>
<section id="when-i-launch-my-application-through-renderdoc-why-can-t-i-access-the-api-validation">
<h2>When I launch my application through RenderDoc, why can’t I access the API validation?<a class="headerlink" href="#when-i-launch-my-application-through-renderdoc-why-can-t-i-access-the-api-validation" title="Permalink to this heading">¶</a></h2>
<p>API validation layers are controlled by RenderDoc when it’s active. This means that enabling the API validation from your application will have no effect, it will be controlled by the <code class="docutils literal notranslate"><span class="pre">Enable</span> <span class="pre">API</span> <span class="pre">Validation</span></code> capture option. For more information see <a class="reference internal" href="../window/capture_attach.html#capture-options"><span class="std std-ref">Capture Options</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>On D3D11 if you know what you are doing you can access the underlying <code class="docutils literal notranslate"><span class="pre">ID3D11InfoQueue</span></code> using the separate UUID <code class="docutils literal notranslate"><span class="pre">{3FC4E618-3F70-452A-8B8F-A73ACCB58E3D}</span></code>. Be aware that accessing this interface is done at your own risk and may break the RenderDoc capture. If you need to use the API validation directly it’s recommended that you do so without RenderDoc active.</p>
</div>
</section>
<section id="if-i-have-multiple-gpus-available-which-one-is-used-by-renderdoc-can-i-change-that">
<h2>If I have multiple GPUs available, which one is used by RenderDoc? Can I change that?<a class="headerlink" href="#if-i-have-multiple-gpus-available-which-one-is-used-by-renderdoc-can-i-change-that" title="Permalink to this heading">¶</a></h2>
<p>By default RenderDoc will try to use the closest matching GPU to the one used on capture, which is controlled by the application. For example if a system has both Nvidia and AMD GPUs, then if the capture was made on an AMD GPU then the AMD GPU will be used on replay.</p>
<p>If a compatible GPU cannot be found - e.g. if the capture was made on an Intel GPU then the default - then the system default will be used.</p>
<p>This selection process can be overridden using <a class="reference internal" href="../how/how_control_replay.html#gpu-selection-override"><span class="std std-ref">the GPU selection replay option</span></a> on a per-capture or global basis.</p>
</section>
<section id="what-is-a-drawcall">
<span id="what-is-an-action"></span><span id="id1"></span><h2>What is an Action?<a class="headerlink" href="#what-is-a-drawcall" title="Permalink to this heading">¶</a></h2>
<p>RenderDoc uses ‘action’ as an umbrella term to cover events like draws, dispatches, copies, clears, resolves, and other calls that cause the GPU to do work or can affect memory and resources like textures and buffers. This is sometimes referred to as a drawcall, but the term action is used to be less ambiguous compared to actual rasterization drawing.</p>
<p>This means that when browsing in the event browser by default only actions will be shown, meaning you can only see the list of actions and user-defined markers.</p>
</section>
</section>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="gotchas_known_issues.html" class="btn btn-neutral float-right" title="Gotchas &amp; Known Issues" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="quick_start.html" class="btn btn-neutral float-left" title="Quick Start" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2023, Baldur Karlsson.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
  

  
  
    
   

</body>
</html>