

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  
  <meta charset="utf-8" />
  
  <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Remote Capture and Replay &mdash; RenderDoc documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/sphinx_paramlinks.css" type="text/css" />

  
  

  
  
    <link rel="canonical" href="https://renderdoc.org/docs/python_api/examples/renderdoc/remote_capture.html"/>
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="qrenderdoc examples" href="../qrenderdoc/index.html" />
    <link rel="prev" title="Display texture in window" href="display_window.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> RenderDoc
          

          
          </a>

          
            
            
              <div class="version">
                1.28
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../credits_acknowledgements.html">Credits &amp; Acknowledgements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/index.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../behind_scenes/index.html">Behind the scenes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../in_application_api.html">In-application API</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">Python API</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../renderdoc_intro.html">Getting Started (python)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../qrenderdoc_intro.html">Getting Started (RenderDoc UI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../dev_environment.html">Python development environment</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ui_extensions.html">Writing UI extensions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../basics.html">Basic Interfaces</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">renderdoc Examples</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="iter_actions.html">Iterate Action tree</a></li>
<li class="toctree-l3"><a class="reference internal" href="fetch_shader.html">Fetch Shader details</a></li>
<li class="toctree-l3"><a class="reference internal" href="fetch_counters.html">Fetch GPU Counter Data</a></li>
<li class="toctree-l3"><a class="reference internal" href="save_texture.html">Save a texture to disk</a></li>
<li class="toctree-l3"><a class="reference internal" href="decode_mesh.html">Decoding Mesh Data</a></li>
<li class="toctree-l3"><a class="reference internal" href="display_window.html">Display texture in window</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Remote Capture and Replay</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#example-source">Example Source</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../qrenderdoc/index.html">qrenderdoc examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../renderdoc/index.html">renderdoc API Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../qrenderdoc/index.html">qrenderdoc API Reference</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../how/index.html">How do I …?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../window/index.html">Window reference</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">RenderDoc</a>
        
      </nav>
      


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          
          
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Python API</a> &raquo;</li>
        
          <li><a href="index.html">renderdoc Examples</a> &raquo;</li>
        
      <li>Remote Capture and Replay</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            
              <a href="https://github.com/baldurk/renderdoc/blob/v1.28/docs/python_api/examples/renderdoc/remote_capture.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="remote-capture-and-replay">
<h1>Remote Capture and Replay<a class="headerlink" href="#remote-capture-and-replay" title="Permalink to this heading">¶</a></h1>
<p>This example is a bit different since it’s not ready-to-run. It provides a template for how you can capture and replay on a remote machine, instead of the local machine. It also shows how to use device protocols to automatically manage devices.</p>
<p>First we can enumerate which device protocols are currently supported.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">protocols</span> <span class="o">=</span> <span class="n">rd</span><span class="o">.</span><span class="n">GetSupportedDeviceProtocols</span><span class="p">()</span>
</pre></div>
</div>
<p>Each string in the list corresponds to a protocol that can be used for managing devices. If we’re using one we can call <a class="reference internal" href="../../renderdoc/replay.html#renderdoc.GetDeviceProtocolController" title="renderdoc.GetDeviceProtocolController"><code class="xref py py-func docutils literal notranslate"><span class="pre">GetDeviceProtocolController()</span></code></a> passing the protocol name and retrieve the controller.</p>
<p>The controller provides a few methods for managing devices. First we can call <a class="reference internal" href="../../renderdoc/replay.html#renderdoc.DeviceProtocolController.GetDevices" title="renderdoc.DeviceProtocolController.GetDevices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GetDevices()</span></code></a> to return a list of device IDs. The format of these device IDs is protocol-dependent but will be equivalent to a normal hostname. Devices may have human-readable names obtainable via <a class="reference internal" href="../../renderdoc/replay.html#renderdoc.DeviceProtocolController.GetFriendlyName" title="renderdoc.DeviceProtocolController.GetFriendlyName"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GetFriendlyName()</span></code></a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">protocol</span> <span class="o">=</span> <span class="n">rd</span><span class="o">.</span><span class="n">GetDeviceProtocolController</span><span class="p">(</span><span class="n">protocol_to_use</span><span class="p">)</span>

<span class="n">devices</span> <span class="o">=</span> <span class="n">protocol</span><span class="o">.</span><span class="n">GetDevices</span><span class="p">()</span>

<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">devices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;no </span><span class="si">{</span><span class="n">protocol_to_use</span><span class="si">}</span><span class="s2"> devices connected&quot;</span><span class="p">)</span>

<span class="c1"># Choose the first device</span>
<span class="n">dev</span> <span class="o">=</span> <span class="n">devices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">name</span> <span class="o">=</span> <span class="n">protocol</span><span class="o">.</span><span class="n">GetFriendlyName</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Running test on </span><span class="si">{</span><span class="n">dev</span><span class="si">}</span><span class="s2"> - named </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">URL</span> <span class="o">=</span> <span class="n">protocol</span><span class="o">.</span><span class="n">GetProtocolName</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;://&quot;</span> <span class="o">+</span> <span class="n">dev</span>
</pre></div>
</div>
<p>The URL will be used the same as we would use a hostname, when connecting for target control or remote servers.</p>
<p>Note that protocols may have additional restrictions - be sure to check <a class="reference internal" href="../../renderdoc/replay.html#renderdoc.DeviceProtocolController.IsSupported" title="renderdoc.DeviceProtocolController.IsSupported"><code class="xref py py-meth docutils literal notranslate"><span class="pre">IsSupported()</span></code></a> to check if the device is expected to function at all, and <a class="reference internal" href="../../renderdoc/replay.html#renderdoc.DeviceProtocolController.SupportsMultiplePrograms" title="renderdoc.DeviceProtocolController.SupportsMultiplePrograms"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SupportsMultiplePrograms()</span></code></a> to see if it supports launching multiple programs. If multiple programs are not supported, you should ensure all running capturable programs are closed before launching a new one.</p>
<p>To begin with we create a remote server connection using <a class="reference internal" href="../../renderdoc/replay.html#renderdoc.CreateRemoteServerConnection" title="renderdoc.CreateRemoteServerConnection"><code class="xref py py-func docutils literal notranslate"><span class="pre">CreateRemoteServerConnection()</span></code></a>. The URL is as constructed above for protocol-based connections, or a simple hostname/IP if we’re connecting directly to remote machine.</p>
<p>If the connection fails, normally we must fail but if we have a device protocol available we can attempt to launch the remote server automatically using <a class="reference internal" href="../../renderdoc/replay.html#renderdoc.DeviceProtocolController.StartRemoteServer" title="renderdoc.DeviceProtocolController.StartRemoteServer"><code class="xref py py-meth docutils literal notranslate"><span class="pre">StartRemoteServer()</span></code></a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">result</span> <span class="o">==</span> <span class="n">rd</span><span class="o">.</span><span class="n">ResultCode</span><span class="o">.</span><span class="n">NetworkIOFailed</span> <span class="ow">and</span> <span class="n">protocol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
  <span class="c1"># If there&#39;s just no I/O, most likely the server is not running. If we have</span>
  <span class="c1"># a protocol, we can try to start the remote server</span>
  <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Couldn&#39;t connect to remote server, trying to start it&quot;</span><span class="p">)</span>

  <span class="n">result</span> <span class="o">=</span> <span class="n">protocol</span><span class="o">.</span><span class="n">StartRemoteServer</span><span class="p">(</span><span class="n">URL</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">result</span> <span class="o">!=</span> <span class="n">rd</span><span class="o">.</span><span class="n">ResultCode</span><span class="o">.</span><span class="n">Succeeded</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Couldn&#39;t launch remote server, got error </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

  <span class="c1"># Try to connect again!</span>
  <span class="n">result</span><span class="p">,</span><span class="n">remote</span> <span class="o">=</span> <span class="n">rd</span><span class="o">.</span><span class="n">CreateRemoteServerConnection</span><span class="p">(</span><span class="n">URL</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The remote server connection has a default timeout of 5 seconds. If the connection is unused for 5 seconds, the other side will disconnect and subsequent use of the interface will fail.</p>
</div>
<p>Once we have a remote server connection, we can browse the remote filesystem for the executable we want to launch using <a class="reference internal" href="../../renderdoc/replay.html#renderdoc.RemoteServer.GetHomeFolder" title="renderdoc.RemoteServer.GetHomeFolder"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GetHomeFolder()</span></code></a> and <a class="reference internal" href="../../renderdoc/replay.html#renderdoc.RemoteServer.ListFolder" title="renderdoc.RemoteServer.ListFolder"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ListFolder()</span></code></a>.</p>
<p>Then once we’ve selected the executable, we can launch the remote program for capturing with <a class="reference internal" href="../../renderdoc/replay.html#renderdoc.RemoteServer.ExecuteAndInject" title="renderdoc.RemoteServer.ExecuteAndInject"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ExecuteAndInject()</span></code></a>. This function is almost identical to the local <a class="reference internal" href="../../renderdoc/capturing.html#renderdoc.ExecuteAndInject" title="renderdoc.ExecuteAndInject"><code class="xref py py-func docutils literal notranslate"><span class="pre">ExecuteAndInject()</span></code></a> except that it is not possible to wait for the program to exit.</p>
<p>In our sample, we now place the remote server connection on a background thread that will ping it each second to keep the connection alive while we use a target control connection to trigger a capture in the application.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">ping_remote</span><span class="p">(</span><span class="n">remote</span><span class="p">,</span> <span class="n">kill</span><span class="p">):</span>
  <span class="n">success</span> <span class="o">=</span> <span class="kc">True</span>
  <span class="k">while</span> <span class="n">success</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">kill</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
    <span class="n">success</span> <span class="o">=</span> <span class="n">remote</span><span class="o">.</span><span class="n">Ping</span><span class="p">()</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">kill</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
<span class="n">ping_thread</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">ping_remote</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">remote</span><span class="p">,</span><span class="n">kill</span><span class="p">))</span>
<span class="n">ping_thread</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
<p>To connect to and control an application we use <a class="reference internal" href="../../renderdoc/capturing.html#renderdoc.CreateTargetControl" title="renderdoc.CreateTargetControl"><code class="xref py py-func docutils literal notranslate"><span class="pre">CreateTargetControl()</span></code></a> with the URL as before and the ident returned from <a class="reference internal" href="../../renderdoc/replay.html#renderdoc.RemoteServer.ExecuteAndInject" title="renderdoc.RemoteServer.ExecuteAndInject"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ExecuteAndInject()</span></code></a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">target</span> <span class="o">=</span> <span class="n">rd</span><span class="o">.</span><span class="n">CreateTargetControl</span><span class="p">(</span><span class="n">URL</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">ident</span><span class="p">,</span> <span class="s1">&#39;remote_capture.py&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

<span class="c1"># Here we wait for whichever condition you want</span>
<span class="n">target</span><span class="o">.</span><span class="n">TriggerCapture</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>There are a couple of ways to trigger a capture, both <a class="reference internal" href="../../renderdoc/capturing.html#renderdoc.TargetControl.TriggerCapture" title="renderdoc.TargetControl.TriggerCapture"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TriggerCapture()</span></code></a> and <a class="reference internal" href="../../renderdoc/capturing.html#renderdoc.TargetControl.QueueCapture" title="renderdoc.TargetControl.QueueCapture"><code class="xref py py-meth docutils literal notranslate"><span class="pre">QueueCapture()</span></code></a> depending on whether you want a time-based or frame-based trigger. The application itself can also use the in-application API to trigger a capture.</p>
<p>The target control connection can be intermittently polled for messages using <a class="reference internal" href="../../renderdoc/capturing.html#renderdoc.TargetControl.ReceiveMessage" title="renderdoc.TargetControl.ReceiveMessage"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ReceiveMessage()</span></code></a>, which keeps the connection alive and will return any new information such as the data for a new capture that has been created. A message of type <a class="reference internal" href="../../renderdoc/capturing.html#renderdoc.TargetControlMessageType.NewCapture" title="renderdoc.TargetControlMessageType.NewCapture"><code class="xref py py-data docutils literal notranslate"><span class="pre">NewCapture</span></code></a> indicates a new capture has been created, and <a class="reference internal" href="../../renderdoc/capturing.html#renderdoc.TargetControlMessage.newCapture" title="renderdoc.TargetControlMessage.newCapture"><code class="xref py py-data docutils literal notranslate"><span class="pre">newCapture</span></code></a> contains the information including the path.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">msg</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">ReceiveMessage</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

<span class="c1"># Once msg.type == rd.TargetControlMessageType.NewCapture has been retrieved</span>

<span class="n">cap_path</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">newCapture</span><span class="o">.</span><span class="n">path</span>
<span class="n">cap_id</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">newCapture</span><span class="o">.</span><span class="n">captureId</span>
</pre></div>
</div>
<p>Once the capture has been found we are finished with the target control connection so we can shut it down and stop the background thread that was keeping the remote server connection alive. Using the remote server connection we can copy the capture back to the local machine with <a class="reference internal" href="../../renderdoc/replay.html#renderdoc.RemoteServer.CopyCaptureFromRemote" title="renderdoc.RemoteServer.CopyCaptureFromRemote"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CopyCaptureFromRemote()</span></code></a>. Similarly if we wanted to load a previously made capture that wasn’t on the remote machine <a class="reference internal" href="../../renderdoc/replay.html#renderdoc.RemoteServer.CopyCaptureToRemote" title="renderdoc.RemoteServer.CopyCaptureToRemote"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CopyCaptureToRemote()</span></code></a> would be useful to copy it ready to be opened.</p>
<p>Finally to open the capture we use, and that returns a <a class="reference internal" href="../../renderdoc/replay.html#renderdoc.ReplayController" title="renderdoc.ReplayController"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReplayController</span></code></a> which can be used as normal and will tunnel over the remote server connection. It can be useful to intermittently ping the remote server connection to check that it’s still valid, and remote server and controller calls can be interleaved as long as they don’t overlap on multiple threads.</p>
<section id="example-source">
<h2>Example Source<a class="headerlink" href="#example-source" title="Permalink to this heading">¶</a></h2>
<p><a class="reference download internal" download="" href="../../../_downloads/4fa8dafb30f598b85163954a9b74f7aa/remote_capture.py"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">the</span> <span class="pre">example</span> <span class="pre">script</span></code></a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">renderdoc</span> <span class="k">as</span> <span class="nn">rd</span>
<span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="c1"># This sample is intended as an example of how to do remote capture and replay</span>
<span class="c1"># as well as using device protocols to automatically enumerate remote targets.</span>
<span class="c1">#</span>
<span class="c1"># It is not complete since it requires filling in with custom logic to select</span>
<span class="c1"># the executable and trigger the capture at the desired time</span>
<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;This sample should not be run directly, read the source&quot;</span><span class="p">)</span>

<span class="n">rd</span><span class="o">.</span><span class="n">InitialiseReplay</span><span class="p">(</span><span class="n">rd</span><span class="o">.</span><span class="n">GlobalEnvironment</span><span class="p">(),</span> <span class="p">[])</span>

<span class="n">protocols</span> <span class="o">=</span> <span class="n">rd</span><span class="o">.</span><span class="n">GetSupportedDeviceProtocols</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Supported device protocols: </span><span class="si">{</span><span class="n">protocols</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Protocols are optional - they allow automatic detection and management of</span>
<span class="c1"># devices.</span>
<span class="k">if</span> <span class="n">protocol_to_use</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># the protocol must be supported</span>
    <span class="k">if</span> <span class="n">protocol_to_use</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">protocols</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">protocol_to_use</span><span class="si">}</span><span class="s2"> protocol not supported&quot;</span><span class="p">)</span>

    <span class="n">protocol</span> <span class="o">=</span> <span class="n">rd</span><span class="o">.</span><span class="n">GetDeviceProtocolController</span><span class="p">(</span><span class="n">protocol_to_use</span><span class="p">)</span>

    <span class="n">devices</span> <span class="o">=</span> <span class="n">protocol</span><span class="o">.</span><span class="n">GetDevices</span><span class="p">()</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">devices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;no </span><span class="si">{</span><span class="n">protocol_to_use</span><span class="si">}</span><span class="s2"> devices connected&quot;</span><span class="p">)</span>

    <span class="c1"># Choose the first device</span>
    <span class="n">dev</span> <span class="o">=</span> <span class="n">devices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">protocol</span><span class="o">.</span><span class="n">GetFriendlyName</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Running test on </span><span class="si">{</span><span class="n">dev</span><span class="si">}</span><span class="s2"> - named </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">URL</span> <span class="o">=</span> <span class="n">protocol</span><span class="o">.</span><span class="n">GetProtocolName</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;://&quot;</span> <span class="o">+</span> <span class="n">dev</span>

    <span class="c1"># Protocols can enumerate devices which are not supported. Capture/replay</span>
    <span class="c1"># is not guaranteed to work on these devices</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">protocol</span><span class="o">.</span><span class="n">IsSupported</span><span class="p">(</span><span class="n">URL</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dev</span><span class="si">}</span><span class="s2"> doesn&#39;t support capture/replay - too old?&quot;</span><span class="p">)</span>

    <span class="c1"># Protocol devices may be single-use and not support multiple captured programs</span>
    <span class="c1"># If so, trying to execute a program for capture is an error</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">protocol</span><span class="o">.</span><span class="n">SupportsMultiplePrograms</span><span class="p">(</span><span class="n">URL</span><span class="p">):</span>
        <span class="c1"># check to see if anything is running. Just use the URL</span>
        <span class="n">ident</span> <span class="o">=</span> <span class="n">rd</span><span class="o">.</span><span class="n">EnumerateRemoteTargets</span><span class="p">(</span><span class="n">URL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ident</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> already has a program running on </span><span class="si">{</span><span class="n">ident</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c1"># If you&#39;re not using a protocol then the URL can simply be a hostname.</span>
    <span class="c1"># The remote server must be running already - how that is done is up</span>
    <span class="c1"># to you. Everything else will work the same over a normal TCP connection</span>
    <span class="n">protocol</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">URL</span> <span class="o">=</span> <span class="n">hostname</span>

<span class="c1"># Let&#39;s try to connect</span>
<span class="n">result</span><span class="p">,</span><span class="n">remote</span> <span class="o">=</span> <span class="n">rd</span><span class="o">.</span><span class="n">CreateRemoteServerConnection</span><span class="p">(</span><span class="n">URL</span><span class="p">)</span>

<span class="k">if</span> <span class="n">result</span> <span class="o">==</span> <span class="n">rd</span><span class="o">.</span><span class="n">ResultCode</span><span class="o">.</span><span class="n">NetworkIOFailed</span> <span class="ow">and</span> <span class="n">protocol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># If there&#39;s just no I/O, most likely the server is not running. If we have</span>
    <span class="c1"># a protocol, we can try to start the remote server</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Couldn&#39;t connect to remote server, trying to start it&quot;</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">protocol</span><span class="o">.</span><span class="n">StartRemoteServer</span><span class="p">(</span><span class="n">URL</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">result</span> <span class="o">!=</span> <span class="n">rd</span><span class="o">.</span><span class="n">ResultCode</span><span class="o">.</span><span class="n">Succeeded</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Couldn&#39;t launch remote server, got error </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Try to connect again!</span>
    <span class="n">result</span><span class="p">,</span><span class="n">remote</span> <span class="o">=</span> <span class="n">rd</span><span class="o">.</span><span class="n">CreateRemoteServerConnection</span><span class="p">(</span><span class="n">URL</span><span class="p">)</span>

<span class="k">if</span> <span class="n">result</span> <span class="o">!=</span> <span class="n">rd</span><span class="o">.</span><span class="n">ResultCode</span><span class="o">.</span><span class="n">Succeeded</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Couldn&#39;t connect to remote server, got error </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># We now have a remote connection. This works regardless of whether it&#39;s a device</span>
<span class="c1"># with a protocol or not. In fact we are done with the protocol at this point</span>
<span class="n">protocol</span> <span class="o">=</span> <span class="kc">None</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Got connection to remote server&quot;</span><span class="p">)</span>

<span class="c1"># GetHomeFolder() gives you a good default path to start with.</span>
<span class="c1"># ListFolder() lists the contents of a folder and can recursively</span>
<span class="c1"># browse the remote filesystem.</span>
<span class="n">home</span> <span class="o">=</span> <span class="n">remote</span><span class="o">.</span><span class="n">GetHomeFolder</span><span class="p">()</span>
<span class="n">paths</span> <span class="o">=</span> <span class="n">remote</span><span class="o">.</span><span class="n">ListFolder</span><span class="p">(</span><span class="n">home</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Executables in home folder &#39;</span><span class="si">{</span><span class="n">home</span><span class="si">}</span><span class="s2">&#39;:&quot;</span><span class="p">)</span>

<span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  - &quot;</span> <span class="o">+</span> <span class="n">p</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>

<span class="c1"># Select your executable, perhaps hardcoded or browsing using the above</span>
<span class="c1"># functions</span>
<span class="n">exe</span><span class="p">,</span><span class="n">workingDir</span><span class="p">,</span><span class="n">cmdLine</span><span class="p">,</span><span class="n">env</span><span class="p">,</span><span class="n">opts</span> <span class="o">=</span> <span class="n">select_executable</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Running </span><span class="si">{</span><span class="n">exe</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">remote</span><span class="o">.</span><span class="n">ExecuteAndInject</span><span class="p">(</span><span class="n">exe</span><span class="p">,</span> <span class="n">workingDir</span><span class="p">,</span> <span class="n">cmdLine</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">opts</span><span class="p">)</span>

<span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">result</span> <span class="o">!=</span> <span class="n">rd</span><span class="o">.</span><span class="n">ResultCode</span><span class="o">.</span><span class="n">Succeeded</span><span class="p">:</span>
    <span class="n">remote</span><span class="o">.</span><span class="n">ShutdownServerAndConnection</span><span class="p">()</span>
    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Couldn&#39;t launch </span><span class="si">{</span><span class="n">exe</span><span class="si">}</span><span class="s2">, got error </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">result</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Spin up a thread to keep the remote server connection alive while we make a capture,</span>
<span class="c1"># as it will time out after 5 seconds of inactivity</span>
<span class="k">def</span> <span class="nf">ping_remote</span><span class="p">(</span><span class="n">remote</span><span class="p">,</span> <span class="n">kill</span><span class="p">):</span>
    <span class="n">success</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">while</span> <span class="n">success</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">kill</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
        <span class="n">success</span> <span class="o">=</span> <span class="n">remote</span><span class="o">.</span><span class="n">Ping</span><span class="p">()</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">kill</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
<span class="n">ping_thread</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">ping_remote</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">remote</span><span class="p">,</span><span class="n">kill</span><span class="p">))</span>
<span class="n">ping_thread</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="c1"># Create target control connection</span>
<span class="n">target</span> <span class="o">=</span> <span class="n">rd</span><span class="o">.</span><span class="n">CreateTargetControl</span><span class="p">(</span><span class="n">URL</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">ident</span><span class="p">,</span> <span class="s1">&#39;remote_capture.py&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

<span class="k">if</span> <span class="n">target</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">kill</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
    <span class="n">ping_thread</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="n">remote</span><span class="o">.</span><span class="n">ShutdownServerAndConnection</span><span class="p">()</span>
    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Couldn&#39;t connect to target control for </span><span class="si">{</span><span class="n">exe</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Connected - waiting for desired capture&quot;</span><span class="p">)</span>

<span class="c1"># Wait for the capture condition we want</span>
<span class="n">capture_condition</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Triggering capture&quot;</span><span class="p">)</span>

<span class="n">target</span><span class="o">.</span><span class="n">TriggerCapture</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Pump messages, keep waiting until we get a capture message. Time out after 30 seconds</span>
<span class="n">msg</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
<span class="k">while</span> <span class="n">msg</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">msg</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">rd</span><span class="o">.</span><span class="n">TargetControlMessageType</span><span class="o">.</span><span class="n">NewCapture</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">ReceiveMessage</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="mi">30</span><span class="p">:</span>
        <span class="k">break</span>

<span class="c1"># Close the target connection, we&#39;re done either way</span>
<span class="n">target</span><span class="o">.</span><span class="n">Shutdown</span><span class="p">()</span>
<span class="n">target</span> <span class="o">=</span> <span class="kc">None</span>

<span class="c1"># Stop the background ping thread</span>
<span class="n">kill</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
<span class="n">ping_thread</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

<span class="c1"># If we didn&#39;t get a capture, error now</span>
<span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">rd</span><span class="o">.</span><span class="n">TargetControlMessageType</span><span class="o">.</span><span class="n">NewCapture</span><span class="p">:</span>
    <span class="n">remote</span><span class="o">.</span><span class="n">ShutdownServerAndConnection</span><span class="p">()</span>
    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Didn&#39;t get new capture notification after triggering capture&quot;</span><span class="p">)</span>

<span class="n">cap_path</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">newCapture</span><span class="o">.</span><span class="n">path</span>
<span class="n">cap_id</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">newCapture</span><span class="o">.</span><span class="n">captureId</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Got new capture at </span><span class="si">{</span><span class="n">cap_path</span><span class="si">}</span><span class="s2"> which is frame </span><span class="si">{</span><span class="n">msg</span><span class="o">.</span><span class="n">newCapture</span><span class="o">.</span><span class="n">frameNumber</span><span class="si">}</span><span class="s2"> with </span><span class="si">{</span><span class="n">msg</span><span class="o">.</span><span class="n">newCapture</span><span class="o">.</span><span class="n">api</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># We could save the capture locally</span>
<span class="c1"># remote.CopyCaptureFromRemote(cap_path, local_path, None)</span>


<span class="c1"># Open a replay. It&#39;s recommended to set no proxy preference, but you could</span>
<span class="c1"># call remote.LocalProxies and choose an index.</span>
<span class="c1">#</span>
<span class="c1"># The path must be remote - if the capture isn&#39;t freshly created then you need</span>
<span class="c1"># to copy it with remote.CopyCaptureToRemote()</span>
<span class="n">result</span><span class="p">,</span><span class="n">controller</span> <span class="o">=</span> <span class="n">remote</span><span class="o">.</span><span class="n">OpenCapture</span><span class="p">(</span><span class="n">rd</span><span class="o">.</span><span class="n">RemoteServer</span><span class="o">.</span><span class="n">NoPreference</span><span class="p">,</span> <span class="n">cap_path</span><span class="p">,</span> <span class="n">rd</span><span class="o">.</span><span class="n">ReplayOptions</span><span class="p">(),</span> <span class="kc">None</span><span class="p">)</span>

<span class="k">if</span> <span class="n">result</span> <span class="o">!=</span> <span class="n">rd</span><span class="o">.</span><span class="n">ResultCode</span><span class="o">.</span><span class="n">Succeeded</span><span class="p">:</span>
    <span class="n">remote</span><span class="o">.</span><span class="n">ShutdownServerAndConnection</span><span class="p">()</span>
    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Couldn&#39;t open </span><span class="si">{</span><span class="n">cap_path</span><span class="si">}</span><span class="s2">, got error </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># We can now use replay as normal.</span>
<span class="c1">#</span>
<span class="c1"># The replay is tunnelled over the remote connection, so you don&#39;t have to keep</span>
<span class="c1"># pinging the remote connection while using the controller. Use of the remote</span>
<span class="c1"># connection and controller can be interleaved though you should only access</span>
<span class="c1"># them from one thread at once. If they are both unused for 5 seconds though,</span>
<span class="c1"># the timeout will happen, so if the controller is idle it&#39;s advisable to ping</span>
<span class="c1"># the remote connection</span>

<span class="n">sampleCode</span><span class="p">(</span><span class="n">controller</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shutting down&quot;</span><span class="p">)</span>

<span class="n">controller</span><span class="o">.</span><span class="n">Shutdown</span><span class="p">()</span>

<span class="c1"># We can still use remote here - e.g. capture again, replay something else,</span>
<span class="c1"># save the capture, etc</span>

<span class="n">remote</span><span class="o">.</span><span class="n">ShutdownServerAndConnection</span><span class="p">()</span>

<span class="n">rd</span><span class="o">.</span><span class="n">ShutdownReplay</span><span class="p">()</span>
</pre></div>
</div>
</section>
</section>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="../qrenderdoc/index.html" class="btn btn-neutral float-right" title="qrenderdoc examples" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="display_window.html" class="btn btn-neutral float-left" title="Display texture in window" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2023, Baldur Karlsson.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
  

  
  
    
   

</body>
</html>